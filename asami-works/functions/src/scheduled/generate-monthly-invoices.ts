import { onSchedule } from 'firebase-functions/v2/scheduler';
import { onRequest } from 'firebase-functions/v2/https';
import * as admin from 'firebase-admin';

// Firebase Admin初期化（index.tsで初期化されていない場合）
if (admin.apps.length === 0) {
  admin.initializeApp();
}

const db = admin.firestore();

interface Client {
  id: string;
  clientName: string;
  email: string;
  isActive: boolean;
  contractStartDate: admin.firestore.Timestamp;
  managementFeeSchedule?: ManagementFeeSchedule[];
  paymentMethod?: 'credit_card' | 'bank_transfer';
}

interface ManagementFeeSchedule {
  fromMonth: number;
  toMonth?: number;
  monthlyFee: number;
  description?: string;
}

/**
 * 契約開始日からの経過月数を計算
 */
const calculateMonthsFromStart = (contractStartDate: admin.firestore.Timestamp): number => {
  const startDate = contractStartDate.toDate();
  const now = new Date();
  const months = (now.getFullYear() - startDate.getFullYear()) * 12 +
                 (now.getMonth() - startDate.getMonth()) + 1;
  return Math.max(0, months);
};

/**
 * 現在の月額管理費を取得
 */
const getCurrentMonthlyFee = (client: Client): number => {
  if (!client.managementFeeSchedule || client.managementFeeSchedule.length === 0) {
    return 0;
  }

  const currentMonth = calculateMonthsFromStart(client.contractStartDate);

  for (const schedule of client.managementFeeSchedule) {
    const isInRange = currentMonth >= schedule.fromMonth &&
                     (!schedule.toMonth || currentMonth <= schedule.toMonth);
    if (isInRange) {
      return schedule.monthlyFee;
    }
  }

  return 0;
};

/**
 * 請求書番号を生成
 */
const generateInvoiceNumber = async (): Promise<string> => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');

  // 当月の請求書数を取得
  const invoicesRef = db.collection('invoices');
  const snapshot = await invoicesRef
    .where('billingMonth', '==', `${year}-${month}`)
    .where('isAutoGenerated', '==', true)
    .get();

  const count = snapshot.size + 1;
  const invoiceNumber = `INV-${year}${month}-${String(count).padStart(4, '0')}`;

  return invoiceNumber;
};

/**
 * クライアントの未払い請求書を取得
 */
const getUnpaidInvoices = async (clientId: string): Promise<admin.firestore.QueryDocumentSnapshot[]> => {
  const unpaidSnapshot = await db.collection('invoices')
    .where('clientId', '==', clientId)
    .where('status', 'in', ['sent', 'overdue'])
    .where('isAutoGenerated', '==', true)
    .orderBy('issueDate', 'asc')
    .get();

  return unpaidSnapshot.docs;
};

/**
 * 期間文字列を生成（例：「10/1〜11/30」）
 */
const formatPeriodString = (startDate: Date, endDate: Date): string => {
  const startMonth = startDate.getMonth() + 1;
  const startDay = startDate.getDate();
  const endMonth = endDate.getMonth() + 1;
  const endDay = endDate.getDate();

  return `${startMonth}/${startDay}〜${endMonth}/${endDay}`;
};

/**
 * 毎月1日に自動的に請求書を生成
 * Cloud Schedulerで毎月1日 0:00 (JST) に実行
 */
export const generateMonthlyInvoices = onSchedule({
  schedule: '0 0 1 * *',
  timeZone: 'Asia/Tokyo',
  timeoutSeconds: 540,
  memory: '1GiB'
}, async (event): Promise<void> => {
    console.log('Starting monthly invoice generation...');

    try {
      // 有効なクライアントを取得
      const clientsSnapshot = await db.collection('clients')
        .where('isActive', '==', true)
        .get();

      if (clientsSnapshot.empty) {
        console.log('No active clients found');
        return;
      }

      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const billingMonth = `${year}-${month}`;

      const issueDate = admin.firestore.Timestamp.now();
      // 支払期限: 翌月末
      const dueDate = new Date(year, now.getMonth() + 1, 0); // 翌月の0日 = 当月末
      const dueDateTimestamp = admin.firestore.Timestamp.fromDate(dueDate);

      let successCount = 0;
      let skipCount = 0;
      let errorCount = 0;

      // 各クライアントに対して請求書を生成
      for (const clientDoc of clientsSnapshot.docs) {
        const client = {
          id: clientDoc.id,
          ...clientDoc.data()
        } as Client;

        try {
          // 契約開始日がない場合はスキップ
          if (!client.contractStartDate) {
            console.log(`Skipping client ${client.id}: No contract start date`);
            skipCount++;
            continue;
          }

          // 現在の月額管理費を取得
          const monthlyFee = getCurrentMonthlyFee(client);

          if (monthlyFee <= 0) {
            console.log(`Skipping client ${client.id}: No monthly fee for current month`);
            skipCount++;
            continue;
          }

          // 既に当月の自動生成請求書が存在するかチェック
          const existingInvoiceSnapshot = await db.collection('invoices')
            .where('clientId', '==', client.id)
            .where('billingMonth', '==', billingMonth)
            .where('isAutoGenerated', '==', true)
            .limit(1)
            .get();

          if (!existingInvoiceSnapshot.empty) {
            console.log(`Skipping client ${client.id}: Invoice already exists for ${billingMonth}`);
            skipCount++;
            continue;
          }

          // 未払い請求書をチェック
          const unpaidInvoices = await getUnpaidInvoices(client.id);

          // 請求書番号を生成
          const invoiceNumber = await generateInvoiceNumber();

          // 請求期間を計算
          let billingStartDate: Date;
          let totalMonths = 1;

          if (unpaidInvoices.length > 0) {
            // 未払い請求書がある場合、最も古い請求書の期間から開始
            const oldestUnpaid = unpaidInvoices[0].data();
            if (oldestUnpaid.billingPeriodStart) {
              billingStartDate = oldestUnpaid.billingPeriodStart.toDate();
            } else {
              // billingPeriodStartがない場合はbillingMonthから推測
              const [unpaidYear, unpaidMonth] = oldestUnpaid.billingMonth.split('-').map(Number);
              billingStartDate = new Date(unpaidYear, unpaidMonth - 1, 1);
            }
            totalMonths = unpaidInvoices.length + 1; // 未払い月数 + 当月
          } else {
            // 未払いがない場合は当月のみ
            billingStartDate = new Date(year, now.getMonth(), 1);
          }

          // 請求期間終了日（当月末）
          const billingEndDate = new Date(year, now.getMonth() + 1, 0);

          // 期間文字列を生成
          const periodStr = formatPeriodString(billingStartDate, billingEndDate);

          // 請求書アイテム
          const description = totalMonths > 1
            ? `月額管理費（${periodStr}）${totalMonths}ヶ月分`
            : `月額管理費（${periodStr}）`;

          const items = [
            {
              description,
              quantity: totalMonths,
              unitPrice: monthlyFee,
              amount: monthlyFee * totalMonths
            }
          ];

          const subtotal = monthlyFee * totalMonths;
          const taxRate = 0.1; // 10%
          const taxAmount = Math.floor(subtotal * taxRate);
          const totalAmount = subtotal + taxAmount;

          // 未払い請求書をキャンセル
          const batch = db.batch();
          for (const unpaidDoc of unpaidInvoices) {
            batch.update(unpaidDoc.ref, {
              status: 'cancelled',
              notes: `${billingMonth}の請求書に統合されました`,
              updatedAt: admin.firestore.Timestamp.now()
            });
          }

          // 新しい請求書を作成
          const newInvoiceRef = db.collection('invoices').doc();
          batch.set(newInvoiceRef, {
            clientId: client.id,
            clientName: client.clientName,
            invoiceNumber,
            items,
            subtotal,
            taxRate,
            taxAmount,
            totalAmount,
            issueDate,
            dueDate: dueDateTimestamp,
            status: 'sent',
            isAutoGenerated: true,
            billingMonth,
            billingPeriodStart: admin.firestore.Timestamp.fromDate(billingStartDate),
            billingPeriodEnd: admin.firestore.Timestamp.fromDate(billingEndDate),
            quantity: totalMonths,
            notes: totalMonths > 1
              ? `未払い${unpaidInvoices.length}ヶ月分を含む自動生成された請求書です。`
              : '自動生成された月額管理費の請求書です。',
            createdAt: admin.firestore.Timestamp.now(),
            updatedAt: admin.firestore.Timestamp.now()
          });

          await batch.commit();

          if (unpaidInvoices.length > 0) {
            console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName} (${totalMonths} months, ${unpaidInvoices.length} unpaid invoices cancelled)`);
          } else {
            console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName}`);
          }
          successCount++;

        } catch (error) {
          console.error(`Error generating invoice for client ${client.id}:`, error);
          errorCount++;
        }
      }

      console.log(`Monthly invoice generation completed:`);
      console.log(`- Success: ${successCount}`);
      console.log(`- Skipped: ${skipCount}`);
      console.log(`- Errors: ${errorCount}`);

    } catch (error) {
      console.error('Error in monthly invoice generation:', error);
      throw error;
    }
  });

/**
 * 手動で請求書生成をトリガーするHTTP関数（テスト用）
 * 本番環境では削除またはアクセス制限を追加してください
 */
export const triggerMonthlyInvoiceGeneration = onRequest(async (request, response) => {
  // 簡易的な認証チェック（本番環境では適切な認証を実装してください）
  const authHeader = request.headers['authorization'] || request.headers['Authorization'];
  if (!authHeader || authHeader !== `Bearer ${process.env.ADMIN_SECRET_KEY}`) {
    response.status(401).json({ error: 'Unauthorized' });
    return;
  }

  try {
    console.log('Manual trigger: Starting monthly invoice generation...');

    // generateMonthlyInvoicesのロジックを直接実行
    const clientsSnapshot = await db.collection('clients')
      .where('isActive', '==', true)
      .get();

    if (clientsSnapshot.empty) {
      response.json({ message: 'No active clients found' });
      return;
    }

    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const billingMonth = `${year}-${month}`;

    const issueDate = admin.firestore.Timestamp.now();
    const dueDate = new Date(year, now.getMonth() + 1, 0);
    const dueDateTimestamp = admin.firestore.Timestamp.fromDate(dueDate);

    let successCount = 0;
    let skipCount = 0;
    let errorCount = 0;

    for (const clientDoc of clientsSnapshot.docs) {
      const client = {
        id: clientDoc.id,
        ...clientDoc.data()
      } as Client;

      try {
        if (!client.contractStartDate) {
          console.log(`Skipping client ${client.id}: No contract start date`);
          skipCount++;
          continue;
        }

        const monthlyFee = getCurrentMonthlyFee(client);

        if (monthlyFee <= 0) {
          console.log(`Skipping client ${client.id}: No monthly fee for current month`);
          skipCount++;
          continue;
        }

        const existingInvoiceSnapshot = await db.collection('invoices')
          .where('clientId', '==', client.id)
          .where('billingMonth', '==', billingMonth)
          .where('isAutoGenerated', '==', true)
          .limit(1)
          .get();

        if (!existingInvoiceSnapshot.empty) {
          console.log(`Skipping client ${client.id}: Invoice already exists for ${billingMonth}`);
          skipCount++;
          continue;
        }

        // 未払い請求書をチェック
        const unpaidInvoices = await getUnpaidInvoices(client.id);

        const invoiceNumber = await generateInvoiceNumber();

        // 請求期間を計算
        let billingStartDate: Date;
        let totalMonths = 1;

        if (unpaidInvoices.length > 0) {
          const oldestUnpaid = unpaidInvoices[0].data();
          if (oldestUnpaid.billingPeriodStart) {
            billingStartDate = oldestUnpaid.billingPeriodStart.toDate();
          } else {
            const [unpaidYear, unpaidMonth] = oldestUnpaid.billingMonth.split('-').map(Number);
            billingStartDate = new Date(unpaidYear, unpaidMonth - 1, 1);
          }
          totalMonths = unpaidInvoices.length + 1;
        } else {
          billingStartDate = new Date(year, now.getMonth(), 1);
        }

        const billingEndDate = new Date(year, now.getMonth() + 1, 0);
        const periodStr = formatPeriodString(billingStartDate, billingEndDate);

        const description = totalMonths > 1
          ? `月額管理費（${periodStr}）${totalMonths}ヶ月分`
          : `月額管理費（${periodStr}）`;

        const items = [
          {
            description,
            quantity: totalMonths,
            unitPrice: monthlyFee,
            amount: monthlyFee * totalMonths
          }
        ];

        const subtotal = monthlyFee * totalMonths;
        const taxRate = 0.1;
        const taxAmount = Math.floor(subtotal * taxRate);
        const totalAmount = subtotal + taxAmount;

        // 未払い請求書をキャンセル
        const batch = db.batch();
        for (const unpaidDoc of unpaidInvoices) {
          batch.update(unpaidDoc.ref, {
            status: 'cancelled',
            notes: `${billingMonth}の請求書に統合されました`,
            updatedAt: admin.firestore.Timestamp.now()
          });
        }

        const newInvoiceRef = db.collection('invoices').doc();
        batch.set(newInvoiceRef, {
          clientId: client.id,
          clientName: client.clientName,
          invoiceNumber,
          items,
          subtotal,
          taxRate,
          taxAmount,
          totalAmount,
          issueDate,
          dueDate: dueDateTimestamp,
          status: 'sent',
          isAutoGenerated: true,
          billingMonth,
          billingPeriodStart: admin.firestore.Timestamp.fromDate(billingStartDate),
          billingPeriodEnd: admin.firestore.Timestamp.fromDate(billingEndDate),
          quantity: totalMonths,
          notes: totalMonths > 1
            ? `未払い${unpaidInvoices.length}ヶ月分を含む自動生成された請求書です。`
            : '自動生成された月額管理費の請求書です。',
          createdAt: admin.firestore.Timestamp.now(),
          updatedAt: admin.firestore.Timestamp.now()
        });

        await batch.commit();

        if (unpaidInvoices.length > 0) {
          console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName} (${totalMonths} months, ${unpaidInvoices.length} unpaid invoices cancelled)`);
        } else {
          console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName}`);
        }
        successCount++;

      } catch (error) {
        console.error(`Error generating invoice for client ${client.id}:`, error);
        errorCount++;
      }
    }

    response.json({
      success: true,
      billingMonth,
      successCount,
      skipCount,
      errorCount,
      message: 'Monthly invoice generation completed'
    });

  } catch (error) {
    console.error('Error in manual trigger:', error);
    response.status(500).json({
      success: false,
      error: 'Failed to generate invoices'
    });
  }
});

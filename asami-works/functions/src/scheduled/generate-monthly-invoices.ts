import { onSchedule } from 'firebase-functions/v2/scheduler';
import { onRequest } from 'firebase-functions/v2/https';
import * as admin from 'firebase-admin';

// Firebase Admin初期化（index.tsで初期化されていない場合）
if (admin.apps.length === 0) {
  admin.initializeApp();
}

const db = admin.firestore();

interface Client {
  id: string;
  clientName: string;
  email: string;
  isActive: boolean;
  contractStartDate: admin.firestore.Timestamp;
  managementFeeSchedule?: ManagementFeeSchedule[];
  paymentMethod?: 'credit_card' | 'bank_transfer';
  lastPaidPeriod?: string; // 最後に支払った期間（YYYY-MM形式）
  lastPaidPeriodStart?: admin.firestore.Timestamp; // 支払い完了期間の開始日
  lastPaidPeriodEnd?: admin.firestore.Timestamp; // 支払い完了期間の終了日
}

interface ManagementFeeSchedule {
  fromMonth: number;
  toMonth?: number;
  monthlyFee: number;
  description?: string;
}

/**
 * 契約開始日からの経過月数を計算
 */
const calculateMonthsFromStart = (contractStartDate: admin.firestore.Timestamp): number => {
  const startDate = contractStartDate.toDate();
  const now = new Date();
  const months = (now.getFullYear() - startDate.getFullYear()) * 12 +
                 (now.getMonth() - startDate.getMonth()) + 1;
  return Math.max(0, months);
};

/**
 * 現在の月額管理費を取得
 */
const getCurrentMonthlyFee = (client: Client): number => {
  if (!client.managementFeeSchedule || client.managementFeeSchedule.length === 0) {
    return 0;
  }

  const currentMonth = calculateMonthsFromStart(client.contractStartDate);

  for (const schedule of client.managementFeeSchedule) {
    const isInRange = currentMonth >= schedule.fromMonth &&
                     (!schedule.toMonth || currentMonth <= schedule.toMonth);
    if (isInRange) {
      return schedule.monthlyFee;
    }
  }

  return 0;
};

/**
 * 請求書番号を生成
 */
const generateInvoiceNumber = async (): Promise<string> => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');

  // 当月の請求書数を取得
  const invoicesRef = db.collection('invoices');
  const snapshot = await invoicesRef
    .where('billingMonth', '==', `${year}-${month}`)
    .where('isAutoGenerated', '==', true)
    .get();

  const count = snapshot.size + 1;
  const invoiceNumber = `INV-${year}${month}-${String(count).padStart(4, '0')}`;

  return invoiceNumber;
};

/**
 * クライアントの未払い請求書を取得
 */
const getUnpaidInvoices = async (clientId: string): Promise<admin.firestore.QueryDocumentSnapshot[]> => {
  const unpaidSnapshot = await db.collection('invoices')
    .where('clientId', '==', clientId)
    .where('status', 'in', ['sent', 'overdue'])
    .where('isAutoGenerated', '==', true)
    .orderBy('issueDate', 'asc')
    .get();

  return unpaidSnapshot.docs;
};

/**
 * 期間文字列を生成（例：「10/1〜11/30」）
 */
const formatPeriodString = (startDate: Date, endDate: Date): string => {
  const startMonth = startDate.getMonth() + 1;
  const startDay = startDate.getDate();
  const endMonth = endDate.getMonth() + 1;
  const endDay = endDate.getDate();

  return `${startMonth}/${startDay}〜${endMonth}/${endDay}`;
};

/**
 * 初月スルーが必要かチェック（契約開始日が当月の場合）
 */
const shouldSkipFirstMonth = (contractStartDate: admin.firestore.Timestamp, currentDate: Date): boolean => {
  const startDate = contractStartDate.toDate();
  return startDate.getFullYear() === currentDate.getFullYear() &&
         startDate.getMonth() === currentDate.getMonth();
};

/**
 * 初回まとめ請求が必要かチェック（契約開始日が前月の場合）
 */
const isFirstBillingMonth = (contractStartDate: admin.firestore.Timestamp, currentDate: Date): boolean => {
  const startDate = contractStartDate.toDate();
  const prevMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
  return startDate.getFullYear() === prevMonth.getFullYear() &&
         startDate.getMonth() === prevMonth.getMonth();
};

/**
 * 毎月1日に自動的に請求書を生成
 * Cloud Schedulerで毎月1日 0:00 (JST) に実行
 */
export const generateMonthlyInvoices = onSchedule({
  schedule: '0 0 1 * *',
  timeZone: 'Asia/Tokyo',
  timeoutSeconds: 540,
  memory: '1GiB'
}, async (event): Promise<void> => {
    console.log('Starting monthly invoice generation...');

    try {
      // 有効なクライアントを取得
      const clientsSnapshot = await db.collection('clients')
        .where('isActive', '==', true)
        .get();

      if (clientsSnapshot.empty) {
        console.log('No active clients found');
        return;
      }

      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const billingMonth = `${year}-${month}`;

      const issueDate = admin.firestore.Timestamp.now();
      // 支払期限: 翌月末
      const dueDate = new Date(year, now.getMonth() + 1, 0); // 翌月の0日 = 当月末
      const dueDateTimestamp = admin.firestore.Timestamp.fromDate(dueDate);

      let successCount = 0;
      let skipCount = 0;
      let errorCount = 0;

      // 各クライアントに対して請求書を生成
      for (const clientDoc of clientsSnapshot.docs) {
        const client = {
          id: clientDoc.id,
          ...clientDoc.data()
        } as Client;

        try {
          // 契約開始日がない場合はスキップ
          if (!client.contractStartDate) {
            console.log(`Skipping client ${client.id}: No contract start date`);
            skipCount++;
            continue;
          }

          // 初月スルー：契約開始日が当月の場合はスキップ
          if (shouldSkipFirstMonth(client.contractStartDate, now)) {
            console.log(`Skipping client ${client.id}: First month skip (contract started this month)`);
            skipCount++;
            continue;
          }

          // 現在の月額管理費を取得
          const monthlyFee = getCurrentMonthlyFee(client);

          if (monthlyFee <= 0) {
            console.log(`Skipping client ${client.id}: No monthly fee for current month`);
            skipCount++;
            continue;
          }

          // 既に当月の自動生成請求書が存在するかチェック
          const existingInvoiceSnapshot = await db.collection('invoices')
            .where('clientId', '==', client.id)
            .where('billingMonth', '==', billingMonth)
            .where('isAutoGenerated', '==', true)
            .limit(1)
            .get();

          if (!existingInvoiceSnapshot.empty) {
            console.log(`Skipping client ${client.id}: Invoice already exists for ${billingMonth}`);
            skipCount++;
            continue;
          }

          // 支払い完了期間をチェック（既に支払い済みの期間はスキップ）
          // 優先順位: lastPaidPeriodEnd > lastPaidPeriod
          if (client.lastPaidPeriodEnd) {
            const lastPaidEnd = client.lastPaidPeriodEnd.toDate();
            const billingEndDate = new Date(year, now.getMonth() + 1, 0); // 当月末

            // 当月末が支払い済み期間に含まれる場合はスキップ
            if (billingEndDate <= lastPaidEnd) {
              console.log(`Skipping client ${client.id}: Already paid until ${lastPaidEnd.toISOString().split('T')[0]}`);
              skipCount++;
              continue;
            }
          } else if (client.lastPaidPeriod) {
            // 後方互換性: lastPaidPeriod（YYYY-MM形式）を使用
            const [paidYear, paidMonth] = client.lastPaidPeriod.split('-').map(Number);
            const paidDate = new Date(paidYear, paidMonth - 1, 1);
            const currentBillingDate = new Date(year, now.getMonth(), 1);

            // 当月が既に支払い済みの場合はスキップ
            if (currentBillingDate <= paidDate) {
              console.log(`Skipping client ${client.id}: Already paid for ${billingMonth} (lastPaidPeriod: ${client.lastPaidPeriod})`);
              skipCount++;
              continue;
            }
          }

          // 未払い請求書をチェック
          const unpaidInvoices = await getUnpaidInvoices(client.id);

          // 請求書番号を生成
          const invoiceNumber = await generateInvoiceNumber();

          // 請求期間を計算
          let billingStartDate: Date;
          let totalMonths = 1;
          let isFirstBilling = false;
          let proratedAmount = 0;

          if (unpaidInvoices.length > 0) {
            // 未払い請求書がある場合、最も古い請求書の期間から開始
            const oldestUnpaid = unpaidInvoices[0].data();
            if (oldestUnpaid.billingPeriodStart) {
              billingStartDate = oldestUnpaid.billingPeriodStart.toDate();
            } else {
              // billingPeriodStartがない場合はbillingMonthから推測
              const [unpaidYear, unpaidMonth] = oldestUnpaid.billingMonth.split('-').map(Number);
              billingStartDate = new Date(unpaidYear, unpaidMonth - 1, 1);
            }
            totalMonths = unpaidInvoices.length + 1; // 未払い月数 + 当月
          } else if (isFirstBillingMonth(client.contractStartDate, now)) {
            // 初回まとめ請求：契約開始日が前月の場合
            billingStartDate = client.contractStartDate.toDate();
            isFirstBilling = true;
            // 日割り計算（初月日割り + 当月全額）
          } else {
            // 通常の1ヶ月分
            billingStartDate = new Date(year, now.getMonth(), 1);
          }

          // 請求期間終了日（当月末）
          const billingEndDate = new Date(year, now.getMonth() + 1, 0);

          // 期間文字列を生成
          const periodStr = formatPeriodString(billingStartDate, billingEndDate);

          // 金額計算
          let subtotal: number;
          const items: Array<{description: string; quantity: number; unitPrice: number; amount: number}> = [];

          if (isFirstBilling) {
            // 初回まとめ請求：日割り + 残り全月の2行
            const firstMonthEnd = new Date(billingStartDate.getFullYear(), billingStartDate.getMonth() + 1, 0);
            const daysInFirstMonth = firstMonthEnd.getDate();
            const actualDaysInFirstMonth = daysInFirstMonth - billingStartDate.getDate() + 1;
            proratedAmount = Math.round(monthlyFee * actualDaysInFirstMonth / daysInFirstMonth);

            // 1行目：初月の日割り
            const firstMonthNum = billingStartDate.getMonth() + 1;
            const firstPeriodStr = `${firstMonthNum}/${billingStartDate.getDate()}〜${firstMonthNum}/${firstMonthEnd.getDate()}`;
            items.push({
              description: `月額管理費（${firstPeriodStr}）`,
              quantity: 1,
              unitPrice: proratedAmount,
              amount: proratedAmount,
            });

            // 2行目：残りの全月
            const secondMonthStart = new Date(billingStartDate.getFullYear(), billingStartDate.getMonth() + 1, 1);
            if (secondMonthStart <= billingEndDate) {
              let remainingMonthCount = 0;
              const currentMonth = new Date(secondMonthStart);
              while (currentMonth.getMonth() <= billingEndDate.getMonth() && currentMonth.getFullYear() <= billingEndDate.getFullYear()) {
                remainingMonthCount++;
                currentMonth.setMonth(currentMonth.getMonth() + 1);
              }

              if (remainingMonthCount > 0) {
                const secondMonthNum = secondMonthStart.getMonth() + 1;
                const endMonthNum = billingEndDate.getMonth() + 1;
                const endDay = billingEndDate.getDate();
                const secondPeriodStr = `${secondMonthNum}/1〜${endMonthNum}/${endDay}`;

                items.push({
                  description: `月額管理費（${secondPeriodStr}）`,
                  quantity: remainingMonthCount,
                  unitPrice: monthlyFee,
                  amount: monthlyFee * remainingMonthCount,
                });
              }
            }

            subtotal = items.reduce((sum, item) => sum + item.amount, 0);
          } else if (totalMonths > 1) {
            // 未払い統合（月初スタート）
            subtotal = monthlyFee * totalMonths;
            items.push({
              description: `月額管理費（${periodStr}）`,
              quantity: totalMonths,
              unitPrice: monthlyFee,
              amount: subtotal,
            });
          } else {
            // 通常の1ヶ月分
            subtotal = monthlyFee;
            items.push({
              description: `月額管理費（${periodStr}）`,
              quantity: 1,
              unitPrice: monthlyFee,
              amount: subtotal,
            });
          }
          const taxRate = 0.1; // 10%
          const taxAmount = Math.floor(subtotal * taxRate);
          const totalAmount = subtotal + taxAmount;

          // 未払い請求書をキャンセル
          const batch = db.batch();
          for (const unpaidDoc of unpaidInvoices) {
            batch.update(unpaidDoc.ref, {
              status: 'cancelled',
              notes: `${billingMonth}の請求書に統合されました`,
              updatedAt: admin.firestore.Timestamp.now()
            });
          }

          // 新しい請求書を作成
          const newInvoiceRef = db.collection('invoices').doc();
          batch.set(newInvoiceRef, {
            clientId: client.id,
            clientName: client.clientName,
            invoiceNumber,
            items,
            subtotal,
            taxRate,
            taxAmount,
            totalAmount,
            issueDate,
            dueDate: dueDateTimestamp,
            status: 'sent',
            isAutoGenerated: true,
            billingMonth,
            billingPeriodStart: admin.firestore.Timestamp.fromDate(billingStartDate),
            billingPeriodEnd: admin.firestore.Timestamp.fromDate(billingEndDate),
            quantity: totalMonths,
            notes: isFirstBilling
              ? '初回請求（初月日割り + 当月分）の自動生成された請求書です。'
              : totalMonths > 1
                ? `未払い${unpaidInvoices.length}ヶ月分を含む自動生成された請求書です。`
                : '自動生成された月額管理費の請求書です。',
            createdAt: admin.firestore.Timestamp.now(),
            updatedAt: admin.firestore.Timestamp.now()
          });

          await batch.commit();

          if (isFirstBilling) {
            console.log(`Successfully generated first invoice ${invoiceNumber} for client ${client.clientName} (prorated: ¥${proratedAmount})`);
          } else if (unpaidInvoices.length > 0) {
            console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName} (${totalMonths} months, ${unpaidInvoices.length} unpaid invoices cancelled)`);
          } else {
            console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName}`);
          }
          successCount++;

        } catch (error) {
          console.error(`Error generating invoice for client ${client.id}:`, error);
          errorCount++;
        }
      }

      console.log(`Monthly invoice generation completed:`);
      console.log(`- Success: ${successCount}`);
      console.log(`- Skipped: ${skipCount}`);
      console.log(`- Errors: ${errorCount}`);

    } catch (error) {
      console.error('Error in monthly invoice generation:', error);
      throw error;
    }
  });

/**
 * 手動で請求書生成をトリガーするHTTP関数（テスト用）
 * 本番環境では削除またはアクセス制限を追加してください
 */
export const triggerMonthlyInvoiceGeneration = onRequest(async (request, response) => {
  // 簡易的な認証チェック（本番環境では適切な認証を実装してください）
  const authHeader = request.headers['authorization'] || request.headers['Authorization'];
  if (!authHeader || authHeader !== `Bearer ${process.env.ADMIN_SECRET_KEY}`) {
    response.status(401).json({ error: 'Unauthorized' });
    return;
  }

  try {
    console.log('Manual trigger: Starting monthly invoice generation...');

    // generateMonthlyInvoicesのロジックを直接実行
    const clientsSnapshot = await db.collection('clients')
      .where('isActive', '==', true)
      .get();

    if (clientsSnapshot.empty) {
      response.json({ message: 'No active clients found' });
      return;
    }

    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const billingMonth = `${year}-${month}`;

    const issueDate = admin.firestore.Timestamp.now();
    const dueDate = new Date(year, now.getMonth() + 1, 0);
    const dueDateTimestamp = admin.firestore.Timestamp.fromDate(dueDate);

    let successCount = 0;
    let skipCount = 0;
    let errorCount = 0;

    for (const clientDoc of clientsSnapshot.docs) {
      const client = {
        id: clientDoc.id,
        ...clientDoc.data()
      } as Client;

      try {
        if (!client.contractStartDate) {
          console.log(`Skipping client ${client.id}: No contract start date`);
          skipCount++;
          continue;
        }

        // 初月スルー：契約開始日が当月の場合はスキップ
        if (shouldSkipFirstMonth(client.contractStartDate, now)) {
          console.log(`Skipping client ${client.id}: First month skip (contract started this month)`);
          skipCount++;
          continue;
        }

        const monthlyFee = getCurrentMonthlyFee(client);

        if (monthlyFee <= 0) {
          console.log(`Skipping client ${client.id}: No monthly fee for current month`);
          skipCount++;
          continue;
        }

        const existingInvoiceSnapshot = await db.collection('invoices')
          .where('clientId', '==', client.id)
          .where('billingMonth', '==', billingMonth)
          .where('isAutoGenerated', '==', true)
          .limit(1)
          .get();

        if (!existingInvoiceSnapshot.empty) {
          console.log(`Skipping client ${client.id}: Invoice already exists for ${billingMonth}`);
          skipCount++;
          continue;
        }

        // lastPaidPeriodをチェック（既に支払い済みの期間はスキップ）
        if (client.lastPaidPeriod) {
          const [paidYear, paidMonth] = client.lastPaidPeriod.split('-').map(Number);
          const paidDate = new Date(paidYear, paidMonth - 1, 1);
          const currentBillingDate = new Date(year, now.getMonth(), 1);

          if (currentBillingDate <= paidDate) {
            console.log(`Skipping client ${client.id}: Already paid for ${billingMonth} (lastPaidPeriod: ${client.lastPaidPeriod})`);
            skipCount++;
            continue;
          }
        }

        // 未払い請求書をチェック
        const unpaidInvoices = await getUnpaidInvoices(client.id);

        const invoiceNumber = await generateInvoiceNumber();

        // 請求期間を計算
        let billingStartDate: Date;
        let totalMonths = 1;
        let isFirstBilling = false;
        let proratedAmount = 0;

        if (unpaidInvoices.length > 0) {
          const oldestUnpaid = unpaidInvoices[0].data();
          if (oldestUnpaid.billingPeriodStart) {
            billingStartDate = oldestUnpaid.billingPeriodStart.toDate();
          } else {
            const [unpaidYear, unpaidMonth] = oldestUnpaid.billingMonth.split('-').map(Number);
            billingStartDate = new Date(unpaidYear, unpaidMonth - 1, 1);
          }
          totalMonths = unpaidInvoices.length + 1;
        } else if (isFirstBillingMonth(client.contractStartDate, now)) {
          // 初回まとめ請求：契約開始日が前月の場合
          billingStartDate = client.contractStartDate.toDate();
          isFirstBilling = true;
        } else {
          billingStartDate = new Date(year, now.getMonth(), 1);
        }

        const billingEndDate = new Date(year, now.getMonth() + 1, 0);
        const periodStr = formatPeriodString(billingStartDate, billingEndDate);

        // 金額計算
        let subtotal: number;
        const items: Array<{description: string; quantity: number; unitPrice: number; amount: number}> = [];

        if (isFirstBilling) {
          // 初回まとめ請求：日割り + 残り全月の2行
          const firstMonthEnd = new Date(billingStartDate.getFullYear(), billingStartDate.getMonth() + 1, 0);
          const daysInFirstMonth = firstMonthEnd.getDate();
          const actualDaysInFirstMonth = daysInFirstMonth - billingStartDate.getDate() + 1;
          proratedAmount = Math.round(monthlyFee * actualDaysInFirstMonth / daysInFirstMonth);

          // 1行目：初月の日割り
          const firstMonthNum = billingStartDate.getMonth() + 1;
          const firstPeriodStr = `${firstMonthNum}/${billingStartDate.getDate()}〜${firstMonthNum}/${firstMonthEnd.getDate()}`;
          items.push({
            description: `月額管理費（${firstPeriodStr}）`,
            quantity: 1,
            unitPrice: proratedAmount,
            amount: proratedAmount,
          });

          // 2行目：残りの全月
          const secondMonthStart = new Date(billingStartDate.getFullYear(), billingStartDate.getMonth() + 1, 1);
          if (secondMonthStart <= billingEndDate) {
            let remainingMonthCount = 0;
            const currentMonth = new Date(secondMonthStart);
            while (currentMonth.getMonth() <= billingEndDate.getMonth() && currentMonth.getFullYear() <= billingEndDate.getFullYear()) {
              remainingMonthCount++;
              currentMonth.setMonth(currentMonth.getMonth() + 1);
            }

            if (remainingMonthCount > 0) {
              const secondMonthNum = secondMonthStart.getMonth() + 1;
              const endMonthNum = billingEndDate.getMonth() + 1;
              const endDay = billingEndDate.getDate();
              const secondPeriodStr = `${secondMonthNum}/1〜${endMonthNum}/${endDay}`;

              items.push({
                description: `月額管理費（${secondPeriodStr}）`,
                quantity: remainingMonthCount,
                unitPrice: monthlyFee,
                amount: monthlyFee * remainingMonthCount,
              });
            }
          }

          subtotal = items.reduce((sum, item) => sum + item.amount, 0);
        } else if (totalMonths > 1) {
          // 未払い統合（月初スタート）
          subtotal = monthlyFee * totalMonths;
          items.push({
            description: `月額管理費（${periodStr}）`,
            quantity: totalMonths,
            unitPrice: monthlyFee,
            amount: subtotal,
          });
        } else {
          // 通常の1ヶ月分
          subtotal = monthlyFee;
          items.push({
            description: `月額管理費（${periodStr}）`,
            quantity: 1,
            unitPrice: monthlyFee,
            amount: subtotal,
          });
        }

        const taxRate = 0.1;
        const taxAmount = Math.floor(subtotal * taxRate);
        const totalAmount = subtotal + taxAmount;

        // 未払い請求書をキャンセル
        const batch = db.batch();
        for (const unpaidDoc of unpaidInvoices) {
          batch.update(unpaidDoc.ref, {
            status: 'cancelled',
            notes: `${billingMonth}の請求書に統合されました`,
            updatedAt: admin.firestore.Timestamp.now()
          });
        }

        const newInvoiceRef = db.collection('invoices').doc();
        batch.set(newInvoiceRef, {
          clientId: client.id,
          clientName: client.clientName,
          invoiceNumber,
          items,
          subtotal,
          taxRate,
          taxAmount,
          totalAmount,
          issueDate,
          dueDate: dueDateTimestamp,
          status: 'sent',
          isAutoGenerated: true,
          billingMonth,
          billingPeriodStart: admin.firestore.Timestamp.fromDate(billingStartDate),
          billingPeriodEnd: admin.firestore.Timestamp.fromDate(billingEndDate),
          quantity: totalMonths,
          notes: isFirstBilling
            ? '初回請求（初月日割り + 当月分）の自動生成された請求書です。'
            : totalMonths > 1
              ? `未払い${unpaidInvoices.length}ヶ月分を含む自動生成された請求書です。`
              : '自動生成された月額管理費の請求書です。',
          createdAt: admin.firestore.Timestamp.now(),
          updatedAt: admin.firestore.Timestamp.now()
        });

        await batch.commit();

        if (isFirstBilling) {
          console.log(`Successfully generated first invoice ${invoiceNumber} for client ${client.clientName} (prorated: ¥${proratedAmount})`);
        } else if (unpaidInvoices.length > 0) {
          console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName} (${totalMonths} months, ${unpaidInvoices.length} unpaid invoices cancelled)`);
        } else {
          console.log(`Successfully generated invoice ${invoiceNumber} for client ${client.clientName}`);
        }
        successCount++;

      } catch (error) {
        console.error(`Error generating invoice for client ${client.id}:`, error);
        errorCount++;
      }
    }

    response.json({
      success: true,
      billingMonth,
      successCount,
      skipCount,
      errorCount,
      message: 'Monthly invoice generation completed'
    });

  } catch (error) {
    console.error('Error in manual trigger:', error);
    response.status(500).json({
      success: false,
      error: 'Failed to generate invoices'
    });
  }
});

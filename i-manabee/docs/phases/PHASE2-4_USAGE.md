# ğŸ“Š Phase 2.4: ä½¿ç”¨é‡ç®¡ç†å®Ÿè£…ä»•æ§˜

æœ€çµ‚æ›´æ–°: 2025-10-07  
Version: 1.0.0  
å®Ÿè£…æœŸé–“: Week 6ï¼ˆ2025-11-11 ã€œ 2025-11-17ï¼‰

---

## ğŸ“š å‰æãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

**å¿…èª­ï¼ˆClaude CODEã¯ã“ã‚Œã‚‰ã‚’å…ˆã«èª­ã‚€ã“ã¨ï¼‰**:
1. [DESIGN_SYSTEM.md](../DESIGN_SYSTEM.md) - UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
2. [TYPE_REFERENCE.md](../TYPE_REFERENCE.md) - Usage, TokenLimitå‹
3. [DIRECTORY_STRUCTURE.md](../DIRECTORY_STRUCTURE.md) - ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®
4. [å®Œå…¨ä»•æ§˜æ›¸](../../i-manabeeå®Œå…¨ä»•æ§˜æ›¸.md) - ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã®è©³ç´°

**å‚è€ƒè³‡æ–™**:
- [æ–™é‡‘ãƒ—ãƒ©ãƒ³](../MASTER_PLAN.md) - ãƒ—ãƒ©ãƒ³åˆ¥ã®åˆ¶é™

---

## ğŸ¯ ã“ã®ãƒ•ã‚§ãƒ¼ã‚ºã®ç›®çš„

ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨é‡ã‚’è¿½è·¡ã—ã€ãƒ—ãƒ©ãƒ³åˆ¥ã®åˆ¶é™ã‚’é©ç”¨ã™ã‚‹ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½¿ç”¨çŠ¶æ³ã‚’ç¢ºèªã§ãã‚‹UIã‚’æä¾›ã™ã‚‹ã€‚

### é”æˆç›®æ¨™
- [ ] ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨é‡ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¿½è·¡ã§ãã‚‹
- [ ] ãƒ—ãƒ©ãƒ³åˆ¥ã®åˆ¶é™ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹
- [ ] 1æ—¥2æœŸåˆ¶ï¼ˆ6æ™‚ãƒ»18æ™‚ãƒªã‚»ãƒƒãƒˆï¼‰ãŒå‹•ä½œã™ã‚‹
- [ ] ä½¿ç”¨é‡ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§çŠ¶æ³ãŒè¦‹ãˆã‚‹
- [ ] ä½¿ç”¨å±¥æ­´ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] åˆ¶é™è¶…éæ™‚ã«é©åˆ‡ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚‹

---

## âœ… å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Day 36-37: ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 

#### Day 36: ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å®Ÿè£…
- [ ] `lib/usage/tokenCounter.ts` ä½œæˆ
- [ ] tiktokençµ±åˆï¼ˆGPTç”¨ï¼‰
- [ ] Gemini/Claudeç”¨ã®æ¦‚ç®—ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
- [ ] UniversalTokenCounterå®Ÿè£…

#### Day 37: Firestoreä½¿ç”¨é‡è¨˜éŒ²
- [ ] `lib/usage/tracker.ts` ä½œæˆ
- [ ] ä½¿ç”¨é‡è¨˜éŒ²é–¢æ•°
- [ ] æœŸåˆ¥é›†è¨ˆ
- [ ] æ—¥æ¬¡é›†è¨ˆ

### Day 38-39: åˆ¶é™ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½

#### Day 38: Limiterå®Ÿè£…
- [ ] `lib/usage/limiter.ts` ä½œæˆ
- [ ] ãƒ—ãƒ©ãƒ³åˆ¥åˆ¶é™å–å¾—
- [ ] æ®‹é‡ãƒã‚§ãƒƒã‚¯é–¢æ•°
- [ ] åˆ¶é™è¶…éåˆ¤å®š

#### Day 39: APIçµ±åˆ
- [ ] `app/api/usage/route.ts` ä½œæˆ
- [ ] ç¾åœ¨ã®ä½¿ç”¨é‡å–å¾—API
- [ ] åˆ¶é™ãƒã‚§ãƒƒã‚¯API
- [ ] ãƒãƒ£ãƒƒãƒˆAPIã«åˆ¶é™ãƒã‚§ãƒƒã‚¯è¿½åŠ 

### Day 40-41: ä½¿ç”¨é‡UI

#### Day 40: ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] `app/(dashboard)/usage/page.tsx` ä½œæˆ
- [ ] `components/dashboard/UsageChart.tsx` ä½œæˆ
- [ ] `components/dashboard/UsageSummary.tsx` ä½œæˆ
- [ ] æ®‹é‡è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

#### Day 41: ä½¿ç”¨å±¥æ­´ã‚°ãƒ©ãƒ•
- [ ] Rechartsçµ±åˆ
- [ ] æ—¥åˆ¥ä½¿ç”¨é‡ã‚°ãƒ©ãƒ•
- [ ] æ•™ç§‘åˆ¥ä½¿ç”¨é‡ã‚°ãƒ©ãƒ•
- [ ] æœŸåˆ¥ä½¿ç”¨é‡è¡¨ç¤º

### Day 42: ãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–

- [ ] å…¨æ©Ÿèƒ½ã®å‹•ä½œç¢ºèª
- [ ] ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- [ ] PROGRESS.mdæ›´æ–°

---

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ãƒˆãƒ¼ã‚¯ãƒ³è¿½è·¡ãƒ•ãƒ­ãƒ¼
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
â†“
ãƒãƒ£ãƒƒãƒˆAPIå‘¼ã³å‡ºã—
â†“

ç¾åœ¨ã®ä½¿ç”¨é‡ã‚’å–å¾—
â†“
åˆ¶é™ãƒã‚§ãƒƒã‚¯
â”œâ”€ åˆ¶é™å†… â†’ AIãƒªã‚¯ã‚¨ã‚¹ãƒˆç¶šè¡Œ
â””â”€ åˆ¶é™è¶…é â†’ ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
â†“
AIãƒ¬ã‚¹ãƒãƒ³ã‚¹å–å¾—
â†“
ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚«ã‚¦ãƒ³ãƒˆ
â†“
Firestoreã«ä½¿ç”¨é‡è¨˜éŒ²
â”œâ”€ usageã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ï¼ˆæœŸåˆ¥ï¼‰
â””â”€ æ—¥æ¬¡é›†è¨ˆæ›´æ–°
â†“
ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¿”å´


### æœŸã®ãƒªã‚»ãƒƒãƒˆä»•çµ„ã¿
Cloud Functions (Scheduled)
â†“
æ¯æ—¥ 6:00 ã¨ 18:00 ã«å®Ÿè¡Œ
â†“
å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœŸåˆ¥ä½¿ç”¨é‡ã‚’ãƒªã‚»ãƒƒãƒˆ
â”œâ”€ morningæœŸï¼ˆ6:00ï¼‰: eveningæœŸã®å€¤ã‚’ morningæœŸã«ç§»å‹•ã€eveningæœŸã‚’ãƒªã‚»ãƒƒãƒˆ
â””â”€ eveningæœŸï¼ˆ18:00ï¼‰: morningæœŸã®å€¤ã‚’ eveningæœŸã«ç§»å‹•ã€morningæœŸã‚’ãƒªã‚»ãƒƒãƒˆ

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆï¼ˆæ–°è¦ä½œæˆåˆ†ï¼‰
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ (dashboard)/
â”‚   â”‚   â””â”€â”€ usage/
â”‚   â”‚       â””â”€â”€ page.tsx              âœ¨ æ–°è¦
â”‚   â”‚
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ usage/
â”‚           â”œâ”€â”€ route.ts              âœ¨ æ–°è¦ï¼ˆä½¿ç”¨é‡å–å¾—ï¼‰
â”‚           â””â”€â”€ history/
â”‚               â””â”€â”€ route.ts          âœ¨ æ–°è¦ï¼ˆå±¥æ­´å–å¾—ï¼‰
â”‚
â”œâ”€â”€ components/
â”‚   â””â”€â”€ dashboard/
â”‚       â”œâ”€â”€ UsageChart.tsx            âœ¨ æ–°è¦
â”‚       â”œâ”€â”€ UsageSummary.tsx          âœ¨ æ–°è¦
â”‚       â””â”€â”€ UsageProgress.tsx         âœ¨ æ–°è¦
â”‚
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ usage/
â”‚       â”œâ”€â”€ tokenCounter.ts           âœ¨ æ–°è¦
â”‚       â”œâ”€â”€ tracker.ts                âœ¨ æ–°è¦
â”‚       â””â”€â”€ limiter.ts                âœ¨ æ–°è¦
â”‚
â””â”€â”€ stores/
â””â”€â”€ usageStore.ts                 âœ¨ æ–°è¦

---

## ğŸ“± ç”»é¢ä»•æ§˜

### 1. ä½¿ç”¨çŠ¶æ³ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ (`/usage`)

#### UIè¦ä»¶
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä½¿ç”¨çŠ¶æ³                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  ä»ŠæœŸã®ä½¿ç”¨çŠ¶æ³ï¼ˆæœã®æœŸ: 6:00-18:00ï¼‰               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â– â– â– â– â– â– â– â– â– â– â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  2,500 / 4,000   â”‚   â”‚
â”‚  â”‚                                             â”‚   â”‚
â”‚  â”‚ æ®‹ã‚Š: 1,500ãƒˆãƒ¼ã‚¯ãƒ³                         â”‚   â”‚
â”‚  â”‚ ãƒªã‚»ãƒƒãƒˆã¾ã§: 3æ™‚é–“12åˆ†                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                     â”‚
â”‚  æ•™ç§‘åˆ¥ä½¿ç”¨çŠ¶æ³                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ç®—æ•°  â– â– â– â– â– â–‘  800 ãƒˆãƒ¼ã‚¯ãƒ³               â”‚   â”‚
â”‚  â”‚ å›½èª  â– â– â– â–‘â–‘â–‘  500 ãƒˆãƒ¼ã‚¯ãƒ³               â”‚   â”‚
â”‚  â”‚ è‹±èª  â– â– â– â– â–‘â–‘  700 ãƒˆãƒ¼ã‚¯ãƒ³               â”‚   â”‚
â”‚  â”‚ ç†ç§‘  â– â– â– â–‘â–‘â–‘  500 ãƒˆãƒ¼ã‚¯ãƒ³               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                     â”‚
â”‚  ä½¿ç”¨å±¥æ­´ï¼ˆéå»7æ—¥é–“ï¼‰                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚        â”ƒ                                    â”‚   â”‚
â”‚  â”‚    â”ƒ   â”ƒ       â”ƒ                            â”‚   â”‚
â”‚  â”‚ â”ƒ  â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ                    â”‚   â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”             â”‚   â”‚
â”‚  â”‚ æœˆ  ç«  æ°´  æœ¨  é‡‘  åœŸ  æ—¥                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

#### ã‚³ãƒ¼ãƒ‰ä¾‹

**`app/(dashboard)/usage/page.tsx`**
```tsx
'use client';

import { useEffect, useState } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { UsageSummary } from '@/components/dashboard/UsageSummary';
import { UsageChart } from '@/components/dashboard/UsageChart';
import { UsageProgress } from '@/components/dashboard/UsageProgress';
import type { Usage } from '@/types';

export default function UsagePage() {
  const { user } = useAuth();
  const [currentUsage, setCurrentUsage] = useState<Usage | null>(null);
  const [history, setHistory] = useState<Usage[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    if (!user) return;
    
    const fetchUsage = async () => {
      try {
        // ç¾åœ¨ã®ä½¿ç”¨é‡ã‚’å–å¾—
        const response = await fetch('/api/usage');
        const data = await response.json();
        setCurrentUsage(data.current);
        
        // å±¥æ­´ã‚’å–å¾—
        const historyResponse = await fetch('/api/usage/history');
        const historyData = await historyResponse.json();
        setHistory(historyData);
      } catch (error) {
        console.error('Failed to fetch usage:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUsage();
    
    // 1åˆ†ã”ã¨ã«æ›´æ–°
    const interval = setInterval(fetchUsage, 60000);
    return () => clearInterval(interval);
  }, [user]);
  
  if (!user) return null;
  
  if (loading) {
    return (
      <div className="max-w-6xl mx-auto">
        <p className="text-gray-600">èª­ã¿è¾¼ã¿ä¸­...</p>
      </div>
    );
  }
  
  return (
    <div className="max-w-6xl mx-auto space-y-8">
      <h1 className="text-2xl font-bold text-gray-800">
        ä½¿ç”¨çŠ¶æ³
      </h1>
      
      {/* Current Usage Summary */}
      {currentUsage && (
        <>
          <UsageSummary usage={currentUsage} plan={user.plan} />
          
          {/* Subject Breakdown */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-bold text-gray-800 mb-4">
              æ•™ç§‘åˆ¥ä½¿ç”¨çŠ¶æ³
            </h2>
            <div className="space-y-3">
              {Object.entries(currentUsage.dailyTotal.subjectBreakdown).map(
                ([subject, tokens]) => (
                  <UsageProgress
                    key={subject}
                    label={getSubjectLabel(subject)}
                    current={tokens}
                    max={getCurrentPeriodLimit(currentUsage, user.plan)}
                    color={getSubjectColor(subject)}
                  />
                )
              )}
            </div>
          </div>
        </>
      )}
      
      {/* Usage History Chart */}
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-bold text-gray-800 mb-4">
          ä½¿ç”¨å±¥æ­´ï¼ˆéå»7æ—¥é–“ï¼‰
        </h2>
        <UsageChart data={history} />
      </div>
      
      {/* Tips */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-6">
        <h3 className="font-bold text-blue-900 mb-2">
          ğŸ’¡ ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç¯€ç´„ã™ã‚‹ã‚³ãƒ„
        </h3>
        <ul className="text-sm text-blue-800 space-y-1">
          <li>â€¢ è³ªå•ã‚’å…·ä½“çš„ã«ã€ç°¡æ½”ã«ã™ã‚‹ã¨åŠ¹ç‡çš„ã§ã™</li>
          <li>â€¢ é•·ã„ä¼šè©±ã¯æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã§å§‹ã‚ã‚‹ã¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç¯€ç´„ã§ãã¾ã™</li>
          <li>â€¢ ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ãªã‚‰ç„¡åˆ¶é™ã§ä½¿ãˆã¾ã™</li>
        </ul>
      </div>
    </div>
  );
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getSubjectLabel(subject: string): string {
  const labels: Record<string, string> = {
    math: 'ç®—æ•°ãƒ»æ•°å­¦',
    japanese: 'å›½èª',
    english: 'è‹±èª',
    science: 'ç†ç§‘',
    social: 'ç¤¾ä¼š',
    programming: 'ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°',
    counseling: 'æ‚©ã¿ç›¸è«‡',
  };
  return labels[subject] || subject;
}

function getSubjectColor(subject: string): string {
  const colors: Record<string, string> = {
    math: '#2196F3',
    japanese: '#FF6B6B',
    english: '#4CAF50',
    science: '#9C27B0',
    social: '#FF9800',
    programming: '#00BCD4',
    counseling: '#FFB300',
  };
  return colors[subject] || '#9E9E9E';
}

function getCurrentPeriodLimit(usage: Usage, plan: string): number {
  const now = new Date();
  const hour = now.getHours();
  const isMorning = hour >= 6 && hour < 18;
  
  const limits: Record<string, { morning: number; evening: number }> = {
    free: { morning: 1000, evening: 1000 },
    kids: { morning: 4000, evening: 4000 },
    friends: { morning: 8000, evening: 8000 },
    premium: { morning: Infinity, evening: Infinity },
  };
  
  const limit = limits[plan] || limits.free;
  return isMorning ? limit.morning : limit.evening;
}
components/dashboard/UsageSummary.tsx
tsximport type { Usage } from '@/types';

interface UsageSummaryProps {
  usage: Usage;
  plan: string;
}

export function UsageSummary({ usage, plan }: UsageSummaryProps) {
  const now = new Date();
  const hour = now.getHours();
  const isMorning = hour >= 6 && hour < 18;
  
  const currentPeriod = isMorning ? usage.periods.morning : usage.periods.evening;
  const limit = getPeriodLimit(plan, isMorning);
  const percentage = limit === Infinity ? 0 : (currentPeriod.tokens / limit) * 100;
  const remaining = limit === Infinity ? Infinity : limit - currentPeriod.tokens;
  
  // ãƒªã‚»ãƒƒãƒˆã¾ã§ã®æ™‚é–“è¨ˆç®—
  const nextReset = new Date();
  if (isMorning) {
    nextReset.setHours(18, 0, 0, 0);
  } else {
    nextReset.setDate(nextReset.getDate() + 1);
    nextReset.setHours(6, 0, 0, 0);
  }
  const msUntilReset = nextReset.getTime() - now.getTime();
  const hoursUntilReset = Math.floor(msUntilReset / (1000 * 60 * 60));
  const minutesUntilReset = Math.floor((msUntilReset % (1000 * 60 * 60)) / (1000 * 60));
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-bold text-gray-800">
          ä»ŠæœŸã®ä½¿ç”¨çŠ¶æ³ï¼ˆ{isMorning ? 'æœã®æœŸ' : 'å¤œã®æœŸ'}: {isMorning ? '6:00-18:00' : '18:00-6:00'}ï¼‰
        </h2>
        <span className="text-sm text-gray-600">
          ãƒªã‚»ãƒƒãƒˆã¾ã§: {hoursUntilReset}æ™‚é–“{minutesUntilReset}åˆ†
        </span>
      </div>
      
      {/* Progress Bar */}
      <div className="mb-4">
        <div className="h-8 bg-gray-200 rounded-full overflow-hidden">
          <div
            className="h-full bg-gradient-to-r from-honey-yellow to-honey-yellow-dark transition-all duration-500"
            style={{ width: `${Math.min(percentage, 100)}%` }}
          />
        </div>
      </div>
      
      {/* Stats */}
      <div className="flex items-center justify-between text-lg">
        <span className="font-medium text-gray-700">
          ä½¿ç”¨é‡: {currentPeriod.tokens.toLocaleString()} ãƒˆãƒ¼ã‚¯ãƒ³
        </span>
        {limit === Infinity ? (
          <span className="font-bold text-green-600">
            ç„¡åˆ¶é™ãƒ—ãƒ©ãƒ³ âœ¨
          </span>
        ) : (
          <span className="font-medium text-gray-700">
            åˆ¶é™: {limit.toLocaleString()} ãƒˆãƒ¼ã‚¯ãƒ³
          </span>
        )}
      </div>
      
      {remaining !== Infinity && (
        <p className="mt-2 text-gray-600">
          æ®‹ã‚Š: {remaining.toLocaleString()} ãƒˆãƒ¼ã‚¯ãƒ³
        </p>
      )}
      
      {/* Warning */}
      {percentage > 80 && percentage < 100 && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
          <p className="text-sm text-yellow-800">
            âš ï¸ æ®‹ã‚Šã‚ãšã‹ã§ã™ã€‚ãƒ—ãƒ©ãƒ³ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’ã”æ¤œè¨ãã ã•ã„ã€‚
          </p>
        </div>
      )}
      
      {percentage >= 100 && (
        <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-sm text-red-800">
            âŒ ä»ŠæœŸã®åˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚æ¬¡ã®ãƒªã‚»ãƒƒãƒˆã¾ã§ãŠå¾…ã¡ã„ãŸã ãã‹ã€ãƒ—ãƒ©ãƒ³ã‚’ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚
          </p>
        </div>
      )}
    </div>
  );
}

function getPeriodLimit(plan: string, isMorning: boolean): number {
  const limits: Record<string, number> = {
    free: 1000,
    kids: 4000,
    friends: 8000,
    premium: Infinity,
  };
  return limits[plan] || limits.free;
}
components/dashboard/UsageProgress.tsx
tsxinterface UsageProgressProps {
  label: string;
  current: number;
  max: number;
  color?: string;
}

export function UsageProgress({ 
  label, 
  current, 
  max, 
  color = '#FFB300' 
}: UsageProgressProps) {
  const percentage = max === Infinity ? 0 : (current / max) * 100;
  
  return (
    <div>
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-medium text-gray-700">{label}</span>
        <span className="text-sm text-gray-600">
          {current.toLocaleString()} ãƒˆãƒ¼ã‚¯ãƒ³
        </span>
      </div>
      <div className="h-3 bg-gray-200 rounded-full overflow-hidden">
        <div
          className="h-full transition-all duration-300"
          style={{
            width: `${Math.min(percentage, 100)}%`,
            backgroundColor: color,
          }}
        />
      </div>
    </div>
  );
}
components/dashboard/UsageChart.tsx
tsx'use client';

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import type { Usage } from '@/types';

interface UsageChartProps {
  data: Usage[];
}

export function UsageChart({ data }: UsageChartProps) {
  // ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
  const chartData = data.map((usage) => ({
    date: new Date(usage.date).toLocaleDateString('ja-JP', {
      month: 'numeric',
      day: 'numeric',
    }),
    tokens: usage.dailyTotal.totalTokens,
    messages: usage.dailyTotal.totalMessages,
  }));
  
  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="date" />
        <YAxis />
        <Tooltip />
        <Legend />
        <Line
          type="monotone"
          dataKey="tokens"
          stroke="#FFB300"
          strokeWidth={2}
          name="ãƒˆãƒ¼ã‚¯ãƒ³æ•°"
        />
        <Line
          type="monotone"
          dataKey="messages"
          stroke="#2196F3"
          strokeWidth={2}
          name="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°"
        />
      </LineChart>
    </ResponsiveContainer>
  );
}

ğŸ”§ ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å®Ÿè£…
lib/usage/tokenCounter.ts
typescriptimport { encoding_for_model } from 'tiktoken';
import type { AIModel } from '@/types';

export class UniversalTokenCounter {
  private gptEncoder = encoding_for_model('gpt-3.5-turbo');
  
  /**
   * ãƒ†ã‚­ã‚¹ãƒˆã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
   */
  count(text: string, model: AIModel): number {
    switch (model) {
      case 'gpt-4o-mini':
        return this.countGPT(text);
        
      case 'gemini-2.5-flash-lite':
        return this.countGemini(text);
        
      case 'claude-sonnet-4.5':
        return this.countClaude(text);
        
      default:
        return this.countApproximate(text);
    }
  }
  
  /**
   * GPTç³»ãƒ¢ãƒ‡ãƒ«ã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ï¼ˆæ­£ç¢ºï¼‰
   */
  private countGPT(text: string): number {
    return this.gptEncoder.encode(text).length;
  }
  
  /**
   * Geminiã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ï¼ˆæ¦‚ç®—ï¼‰
   * Geminiã¯æ–‡å­—æ•°/4ãŒç›®å®‰
   */
  private countGemini(text: string): number {
    return Math.ceil(text.length / 4);
  }
  
  /**
   * Claudeã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ï¼ˆæ¦‚ç®—ï¼‰
   * Claudeã¯ç´„1.3å€ã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°
   */
  private countClaude(text: string): number {
    const baseTokens = Math.ceil(text.length / 3);
    return Math.ceil(baseTokens * 1.3);
  }
  
  /**
   * æ¦‚ç®—ï¼ˆå®‰å…¨ãƒãƒ¼ã‚¸ãƒ³è¾¼ã¿ï¼‰
   */
  private countApproximate(text: string): number {
    return Math.ceil(text.length / 2.5);
  }
  
  /**
   * APIè²»ç”¨è¨ˆç®—ï¼ˆå††ï¼‰
   */
  calculateCost(tokens: number, model: AIModel): number {
    const pricing: Record<AIModel, number> = {
      'gpt-4o-mini': 0.002,            // $0.002/1K tokens
      'gemini-2.5-flash-lite': 0.00035, // $0.00035/1K tokens
      'claude-sonnet-4.5': 0.00025,    // $0.00025/1K tokens
    };
    
    const pricePerK = pricing[model] || 0.002;
    const usdCost = (tokens / 1000) * pricePerK;
    const jpyCost = usdCost * 150; // ç‚ºæ›¿ãƒ¬ãƒ¼ãƒˆ
    
    return jpyCost;
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const tokenCounter = new UniversalTokenCounter();

lib/usage/tracker.ts
typescriptimport { doc, getDoc, setDoc, updateDoc, serverTimestamp } from 'firebase/firestore';
import { db } from '@/lib/firebase/config';
import type { Usage, Subject, AIModel } from '@/types';

/**
 * ä½¿ç”¨é‡ã‚’è¨˜éŒ²
 */
export async function trackUsage(params: {
  userId: string;
  tokens: number;
  messageCount: number;
  subject: Subject;
  model: AIModel;
}): Promise<void> {
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const hour = new Date().getHours();
  const isMorning = hour >= 6 && hour < 18;
  const period = isMorning ? 'morning' : 'evening';
  
  const usageRef = doc(db, 'usage', `${params.userId}_${today}`);
  
  try {
    const usageDoc = await getDoc(usageRef);
    
    if (usageDoc.exists()) {
      // æ—¢å­˜ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°
      const data = usageDoc.data() as Usage;
      
      await updateDoc(usageRef, {
        [`periods.${period}.messages`]: data.periods[period].messages + params.messageCount,
        [`periods.${period}.tokens`]: data.periods[period].tokens + params.tokens,
        'dailyTotal.totalMessages': data.dailyTotal.totalMessages + params.messageCount,
        'dailyTotal.totalTokens': data.dailyTotal.totalTokens + params.tokens,
        'dailyTotal.apiCost': data.dailyTotal.apiCost + calculateCost(params.tokens, params.model),
        [`dailyTotal.subjectBreakdown.${params.subject}`]:
          (data.dailyTotal.subjectBreakdown[params.subject] || 0) + params.tokens,
      });
    } else {
      // æ–°è¦ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆ
      const newUsage: Usage = {
        userId: params.userId,
        date: today,
        periods: {
          morning: {
            messages: period === 'morning' ? params.messageCount : 0,
            tokens: period === 'morning' ? params.tokens : 0,
            resetAt: getNextResetTime('morning'),
            remaining: 0, // å¾Œã§è¨ˆç®—
          },
          evening: {
            messages: period === 'evening' ? params.messageCount : 0,
            tokens: period === 'evening' ? params.tokens : 0,
            resetAt: getNextResetTime('evening'),
            remaining: 0,
          },
        },
        dailyTotal: {
          totalMessages: params.messageCount,
          totalTokens: params.tokens,
          apiCost: calculateCost(params.tokens, params.model),
          subjectBreakdown: {
            [params.subject]: params.tokens,
          },
        },
      };
      
      await setDoc(usageRef, newUsage);
    }
  } catch (error) {
    console.error('Failed to track usage:', error);
    throw error;
  }
}

/**
 * ç¾åœ¨ã®ä½¿ç”¨é‡ã‚’å–å¾—
 */
export async function getCurrentUsage(userId: string): Promise<Usage | null> {
  const today = new Date().toISOString().split('T')[0];
  const usageRef = doc(db, 'usage', `${params.userId}_${today}`);
  
  const usageDoc = await getDoc(usageRef);
  
  if (!usageDoc.exists()) {
    return null;
  }
  
  return usageDoc.data() as Usage;
}

/**
 * ä½¿ç”¨å±¥æ­´ã‚’å–å¾—ï¼ˆéå»Næ—¥é–“ï¼‰
 */
export async function getUsageHistory(
  userId: string,
  days: number = 7
): Promise<Usage[]> {
  const history: Usage[] = [];
  
  for (let i = 0; i < days; i++) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    
    const usageRef = doc(db, 'usage', `${userId}_${dateStr}`);
    const usageDoc = await getDoc(usageRef);
    
    if (usageDoc.exists()) {
      history.push(usageDoc.data() as Usage);
    }
  }
  
  return history.reverse(); // å¤ã„é †ã«
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getNextResetTime(period: 'morning' | 'evening'): Date {
  const now = new Date();
  const reset = new Date();
  
  if (period === 'morning') {
    reset.setHours(6, 0, 0, 0);
    if (now.getHours() >= 6) {
      reset.setDate(reset.getDate() + 1);
    }
  } else {
    reset.setHours(18, 0, 0, 0);
    if (now.getHours() >= 18) {
      reset.setDate(reset.getDate() + 1);
    }
  }
  
  return reset;
}

function calculateCost(tokens: number, model: AIModel): number {
  const pricing: Record<AIModel, number> = {
    'gpt-4o-mini': 0.002,
    'gemini-2.5-flash-lite': 0.00035,
    'claude-sonnet-4.5': 0.00025,
  };
  
  const pricePerK = pricing[model] || 0.002;
  return (tokens / 1000) * pricePerK * 150; // å††æ›ç®—
}

lib/usage/limiter.ts
typescriptimport { getCurrentUsage } from './tracker';
import type { Plan } from '@/types';

export interface TokenLimit {
  plan: Plan;
  messagesPerPeriod: number | 'unlimited';
  tokensPerPeriod: number | 'unlimited';
}

export const TOKEN_LIMITS: Record<Plan, TokenLimit> = {
  free: {
    plan: 'free',
    messagesPerPeriod: 5,
    tokensPerPeriod: 1000,
  },
  kids: {
    plan: 'kids',
    messagesPerPeriod: 'unlimited',
    tokensPerPeriod: 4000,
  },
  friends: {
    plan: 'friends',
    messagesPerPeriod: 'unlimited',
    tokensPerPeriod: 8000,
  },
  premium: {
    plan: 'premium',
    messagesPerPeriod: 'unlimited',
    tokensPerPeriod: 'unlimited',
  },
};

/**
 * åˆ¶é™ãƒã‚§ãƒƒã‚¯
 */
export async function checkLimit(
  userId: string,
  plan: Plan
): Promise<{ allowed: boolean; reason?: string; remaining?: number }> {
  const usage = await getCurrentUsage(userId);
  const limit = TOKEN_LIMITS[plan];
  
  const hour = new Date().getHours();
  const isMorning = hour >= 6 && hour < 18;
  
  // ä½¿ç”¨é‡ãŒãªã„å ´åˆã¯è¨±å¯
  if (!usage) {
    return { allowed: true };
  }
  
  const currentPeriod = isMorning ? usage.periods.morning : usage.periods.evening;
  
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°ãƒã‚§ãƒƒã‚¯
  if (
    limit.messagesPerPeriod !== 'unlimited' &&
    currentPeriod.messages >= limit.messagesPerPeriod
  ) {
    return {
      allowed: false,
      reason: `ä»ŠæœŸã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°ä¸Šé™ï¼ˆ${limit.messagesPerPeriod}å›ï¼‰ã«é”ã—ã¾ã—ãŸ`,
      remaining: 0,
    };
  }
  
  // ãƒˆãƒ¼ã‚¯ãƒ³æ•°ãƒã‚§ãƒƒã‚¯
  if (
    limit.tokensPerPeriod !== 'unlimited' &&
    currentPeriod.tokens >= limit.tokensPerPeriod
  ) {
    return {
      allowed: false,
      reason: `ä»ŠæœŸã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ä¸Šé™ï¼ˆ${limit.tokensPerPeriod}ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ã«é”ã—ã¾ã—ãŸ`,
      remaining: 0,
    };
  }
  
  // æ®‹é‡è¨ˆç®—
  const remaining =
    limit.tokensPerPeriod === 'unlimited'
      ? Infinity
      : limit.tokensPerPeriod - currentPeriod.tokens;
  
  return { allowed: true, remaining };
}

ğŸ”— APIçµ±åˆ
ãƒãƒ£ãƒƒãƒˆAPIã«åˆ¶é™ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
app/api/chat/route.tsï¼ˆæ›´æ–°ï¼‰
typescriptimport { checkLimit } from '@/lib/usage/limiter';
import { trackUsage } from '@/lib/usage/tracker';
import { tokenCounter } from '@/lib/usage/tokenCounter';

export async function POST(request: Request) {
  const { message, childId, subject } = await request.json();
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—
  const user = await getUser();
  
  // åˆ¶é™ãƒã‚§ãƒƒã‚¯ â­ è¿½åŠ 
  const limitCheck = await checkLimit(user.id, user.plan);
  
  if (!limitCheck.allowed) {
    return Response.json(
      { error: limitCheck.reason },
      { status: 429 }
    );
  }
  
  // AIãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  const aiResponse = await getAIResponse(message, subject);
  
  // ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚«ã‚¦ãƒ³ãƒˆ â­ è¿½åŠ 
  const model = getModelForSubject(subject);
  const userTokens = tokenCounter.count(message, model);
  const assistantTokens = tokenCounter.count(aiResponse, model);
  const totalTokens = userTokens + assistantTokens;
  
  // ä½¿ç”¨é‡è¨˜éŒ² â­ è¿½åŠ 
  await trackUsage({
    userId: user.id,
    tokens: totalTokens,
    messageCount: 1,
    subject,
    model,
  });
  
  return Response.json({
    message: aiResponse,
    tokens: totalTokens,
    remaining: limitCheck.remaining,
  });
}

ğŸ§ª ãƒ†ã‚¹ãƒˆ
æ‰‹å‹•ãƒ†ã‚¹ãƒˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ãƒˆ

 GPTã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ãŒæ­£ç¢º
 Gemini/Claudeã®æ¦‚ç®—ãŒå¦¥å½“
 è²»ç”¨è¨ˆç®—ãŒæ­£ç¢º

ä½¿ç”¨é‡è¨˜éŒ²

 ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å¾Œã€Firestoreã«è¨˜éŒ²ã•ã‚Œã‚‹
 æœŸåˆ¥ã«æ­£ã—ãé›†è¨ˆã•ã‚Œã‚‹
 æ•™ç§‘åˆ¥ã«æ­£ã—ãé›†è¨ˆã•ã‚Œã‚‹

åˆ¶é™ãƒã‚§ãƒƒã‚¯

 ç„¡æ–™ãƒ—ãƒ©ãƒ³: 5å›/1000ãƒˆãƒ¼ã‚¯ãƒ³ã§åˆ¶é™
 ã‚­ãƒƒã‚ºãƒ—ãƒ©ãƒ³: 4000ãƒˆãƒ¼ã‚¯ãƒ³ã§åˆ¶é™
 ãƒ•ãƒ¬ãƒ³ã‚ºãƒ—ãƒ©ãƒ³: 8000ãƒˆãƒ¼ã‚¯ãƒ³ã§åˆ¶é™
 ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³: åˆ¶é™ãªã—

UIè¡¨ç¤º

 ä½¿ç”¨é‡ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹
 ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã‚‹
 æ®‹é‡ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹
 åˆ¶é™è¶…éæ™‚ã«è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã‚‹


ğŸ“ Claude CODEã¸ã®æŒ‡ç¤º
å®Ÿè£…æ‰‹é †
Day 36: ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

lib/usage/tokenCounter.ts ä½œæˆ
tiktokençµ±åˆ
ãƒ†ã‚¹ãƒˆ

Day 37: ä½¿ç”¨é‡è¨˜éŒ²

lib/usage/tracker.ts ä½œæˆ
Firestoreçµ±åˆ

Day 38: åˆ¶é™ãƒã‚§ãƒƒã‚¯

lib/usage/limiter.ts ä½œæˆ
ãƒ—ãƒ©ãƒ³åˆ¥åˆ¶é™å®šç¾©

Day 39: APIçµ±åˆ

ãƒãƒ£ãƒƒãƒˆAPIã«çµ±åˆ
åˆ¶é™è¶…éæ™‚ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†

Day 40-41: UIå®Ÿè£…

/usage ãƒšãƒ¼ã‚¸ä½œæˆ
ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

Day 42: ãƒ†ã‚¹ãƒˆ

å…¨æ©Ÿèƒ½ç¢ºèª
ãƒã‚°ä¿®æ­£


ğŸ¯ å®Œäº†åŸºæº–

 ãƒˆãƒ¼ã‚¯ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãŒæ­£ç¢º
 ä½¿ç”¨é‡ãŒFirestoreã«è¨˜éŒ²ã•ã‚Œã‚‹
 ãƒ—ãƒ©ãƒ³åˆ¥åˆ¶é™ãŒæ©Ÿèƒ½ã™ã‚‹
 ä½¿ç”¨é‡ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹
 ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸ
 PROGRESS.mdæ›´æ–°


æœ€çµ‚æ›´æ–°: 2025-10-07
æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚º: PHASE2-5_CHAT.md